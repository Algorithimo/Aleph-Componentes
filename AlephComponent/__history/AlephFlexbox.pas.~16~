unit AlephFlexbox;

interface

uses
  System.Classes, System.SysUtils, System.Generics.Collections, FMX.Types, FMX.Controls, AlephFlexboxInterfaces;

type
  TFlexItem = class(TInterfacedObject, IFlexItem)
  private
    FControl: TControl;
    FFlexGrow: Single;
    FFlexShrink: Single;
    FFlexBasis: Single;
    function GetControl: TControl;
    procedure SetFlexGrow(Value: Single);
    function GetFlexGrow: Single;
    procedure SetFlexShrink(Value: Single);
    function GetFlexShrink: Single;
    procedure SetFlexBasis(Value: Single);
    function GetFlexBasis: Single;
  public
    constructor Create(AControl: TControl);
  end;

  TFlexContainer = class(TControl, IFlexContainer)
  private
    FItems: TObjectList<IFlexItem>;
    FFlexDirection: TFlexDirection;
    FJustifyContent: TJustifyContent;
    FAlignItems: TAlignItems;
    procedure CalculateLayout;
    function GetFlexDirection: TFlexDirection;
    procedure SetFlexDirection(Value: TFlexDirection);
    function GetJustifyContent: TJustifyContent;
    procedure SetJustifyContent(Value: TJustifyContent);
    function GetAlignItems: TAlignItems;
    procedure SetAlignItems(Value: TAlignItems);
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure AddItem(AControl: TControl);
  end;

implementation

{ TFlexItem }

constructor TFlexItem.Create(AControl: TControl);
begin
  inherited Create;
  FControl := AControl;
  FFlexGrow := 0;
  FFlexShrink := 1;
  FFlexBasis := 0;
end;

function TFlexItem.GetControl: TControl;
begin
  Result := FControl;
end;

procedure TFlexItem.SetFlexGrow(Value: Single);
begin
  FFlexGrow := Value;
end;

function TFlexItem.GetFlexGrow: Single;
begin
  Result := FFlexGrow;
end;

procedure TFlexItem.SetFlexShrink(Value: Single);
begin
  FFlexShrink := Value;
end;

function TFlexItem.GetFlexShrink: Single;
begin
  Result := FFlexShrink;
end;

procedure TFlexItem.SetFlexBasis(Value: Single);
begin
  FFlexBasis := Value;
end;

function TFlexItem.GetFlexBasis: Single;
begin
  Result := FFlexBasis;
end;

{ TFlexContainer }

constructor TFlexContainer.Create(AOwner: TComponent);
begin
  inherited;
  FItems := TObjectList<IFlexItem>.Create(True);
  FFlexDirection := TFlexDirection.Row;
  FJustifyContent := TJustifyContent.FlexStart;
  FAlignItems := TAlignItems.Stretch;
end;

destructor TFlexContainer.Destroy;
begin
  FItems.Free;
  inherited;
end;

procedure TFlexContainer.AddItem(AControl: TControl);
var
  Item: IFlexItem;
begin
  Item := TFlexItem.Create(AControl);
  FItems.Add(Item);
  AControl.Parent := Self;
end;

procedure TFlexContainer.CalculateLayout;
var
  TotalSpace, FlexGrowSum, FlexShrinkSum, AvailableSpace: Single;
  Item: IFlexItem;
  ItemSize: Single;
begin
  // Simplificação para direção de linha
  if FFlexDirection in [TFlexDirection.Row, TFlexDirection.RowReverse] then
    TotalSpace := Width
  else
    TotalSpace := Height;

  // Calcular somas de flex-grow e flex-shrink
  FlexGrowSum := 0;
  FlexShrinkSum := 0;
  for Item in FItems do
  begin
    FlexGrowSum := FlexGrowSum + Item.FlexGrow;
    FlexShrinkSum := FlexShrinkSum + Item.FlexShrink;
  end;

  // Calcular espaço disponível
  AvailableSpace := TotalSpace;
  for Item in FItems do
    AvailableSpace := AvailableSpace - Item.FlexBasis;

  // Distribuir espaço
  for Item in FItems do
  begin
    if AvailableSpace > 0 then
      ItemSize := Item.FlexBasis + (AvailableSpace * (Item.FlexGrow / FlexGrowSum))
    else
      ItemSize := Item.FlexBasis + (AvailableSpace * (Item.FlexShrink / FlexShrinkSum));

    // Aplicar tamanho ao controle
    if FFlexDirection in [TFlexDirection.Row, TFlexDirection.RowReverse] then
      Item.Control.Width := ItemSize
    else
      Item.Control.Height := ItemSize;
  end;

  // Posicionar itens (simplificado para FlexStart)
  var Position: Single := 0;
  for Item in FItems do
  begin
    if FFlexDirection in [TFlexDirection.Row, TFlexDirection.RowReverse] then
    begin
      Item.Control.Position.X := Position;
      Position := Position + Item.Control.Width;
    end
    else
    begin
      Item.Control.Position.Y := Position;
      Position := Position + Item.Control.Height;
    end;
  end;
end;

function TFlexContainer.GetFlexDirection: TFlexDirection;
begin
  Result := FFlexDirection;
end;

procedure TFlexContainer.SetFlexDirection(Value: TFlexDirection);
begin
  FFlexDirection := Value;
  CalculateLayout;
end;

function TFlexContainer.GetJustifyContent: TJustifyContent;
begin
  Result := FJustifyContent;
end;

procedure TFlexContainer.SetJustifyContent(Value: TJustifyContent);
begin
  FJustifyContent := Value;
  CalculateLayout;
end;

function TFlexContainer.GetAlignItems: TAlignItems;
begin
  Result := FAlignItems;
end;

procedure TFlexContainer.SetAlignItems(Value: TAlignItems);
begin
  FAlignItems := Value;
  CalculateLayout;
end;

end.

